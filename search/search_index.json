{"config":{"indexing":"full","lang":["en"],"min_search_length":3,"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"","text":"Welcome to Solderix API Documentation This page provides explanations and examples for Solderix-specific imports. All the source code written in MicroPython can be downloaded from the Solderix API Repo . Setting up the enviorment Aside from SolderBrix, the SolderBit can be programmed using a regular text editor and a Python extension. This section will cover how to set up all the required tools to program, develop, and test features on the SolderBit and SolderBit PRO. Installing Python Since SolderBIT uses MicroPython as its programming language, the PC used for programming must support it. This guide shows you how to install Python on a Windows machine. The link to download the latest version of Python is here . During installation, make sure to check the box \"Add Python to PATH\" so Python can be used from any location on your computer. Then, follow the instructions in the installer. Installing Adafruti MicroPython Module After installing Python, you need to install ampy (Adafruit MicroPython). This Python tool is used to transfer code from the computer to the SolderBit. First, open your operating system\u2019s command console. On Windows 11, this can be done by holding Shift and right-clicking, then selecting \"Open PowerShell window here\" or \"Open in Terminal\". Once the terminal is open, run the following command: pip install adafruit-ampy For more information on Adafruit MicroPython, visit their official website . Loading Imports Every SolderBit comes preloaded with the latest imports available at the time of manufacturing. As time passes, these imports need to be updated. This section will go through the manual process of loading not only the official Solderix imports but also custom ones. Requiermantes To continue with this section, Adafruit MicroPython needs to be installed on your machine. Follow the link if Adafruit MicroPython is not already set up. Git helps keep downloads organized, so it\u2019s recommended to install it as well. Download it from - (Git Download Connecting the SolderBit The first step is to connect the SolderBit to the PC using a USB-C cable. If the \"Power\" LED turns on, it means the device is receiving power Connecting SolderBit Downloading the source code All of the source code written in MicroPython can be downloaded from Solderix API Repo . To download the repository, open a terminal in your chosen folder and run the following command: git clone https://github.com/Solderix/SolderBIT-API.git The folder structure of the root folder should look as follows: /bin /images /solderbit /examples /imports /newRadio flash_all_imports.bat flash_car.bat flash_controller.bat README.md Finding the SolderBit COM port To flash the SolderBit, its COM port must be identified. On Windows, open Device Manager and navigate to Ports (COM & LPT). The SolderBit usually appears as USB Serial Device (COMX), where X is a number. Example: USB Serial Device (COM29) Copy the COM number. Navigate to the downloaded source code folder and open flash_all_imports.bat with a text editor (Notepad or any other). Change the COM in the flash_all_imports.bat with the COM copied from the Device Manager. Save changes. Running the Script After completing the steps above, double-click flash_all_imports.bat . A terminal will open, and flashing will begin. This usually takes less than a minute. Once flashing is complete, a list of all imports will be displayed in the terminal. Example: /controller.py /expander.py /follower.py /gpio.py /microbit.py /oled.py /proxy.py /radio.py /sdcard.py /servo.py /srt.py /ultrasonic.py /vehicle.py Loading the main program To load the main program, the ampy (Adafruit MicroPython) module is required. All programs are written in main.py . After writing your program, open a terminal in the folder where main.py is located. Then, enter the command: ampy -p COMx put main.py where COMx is the COM port of the Solderbit. . This command uploads main.py on the Solderbit, and after a hardware reset the program will run.","title":"Home"},{"location":"#welcome-to-solderix-api-documentation","text":"This page provides explanations and examples for Solderix-specific imports. All the source code written in MicroPython can be downloaded from the Solderix API Repo .","title":"Welcome to Solderix API Documentation"},{"location":"#setting-up-the-enviorment","text":"Aside from SolderBrix, the SolderBit can be programmed using a regular text editor and a Python extension. This section will cover how to set up all the required tools to program, develop, and test features on the SolderBit and SolderBit PRO.","title":"Setting up the enviorment"},{"location":"#installing-python","text":"Since SolderBIT uses MicroPython as its programming language, the PC used for programming must support it. This guide shows you how to install Python on a Windows machine. The link to download the latest version of Python is here . During installation, make sure to check the box \"Add Python to PATH\" so Python can be used from any location on your computer. Then, follow the instructions in the installer.","title":"Installing Python"},{"location":"#installing-adafruti-micropython-module","text":"After installing Python, you need to install ampy (Adafruit MicroPython). This Python tool is used to transfer code from the computer to the SolderBit. First, open your operating system\u2019s command console. On Windows 11, this can be done by holding Shift and right-clicking, then selecting \"Open PowerShell window here\" or \"Open in Terminal\". Once the terminal is open, run the following command: pip install adafruit-ampy For more information on Adafruit MicroPython, visit their official website .","title":"Installing Adafruti MicroPython Module"},{"location":"#loading-imports","text":"Every SolderBit comes preloaded with the latest imports available at the time of manufacturing. As time passes, these imports need to be updated. This section will go through the manual process of loading not only the official Solderix imports but also custom ones.","title":"Loading Imports"},{"location":"#requiermantes","text":"To continue with this section, Adafruit MicroPython needs to be installed on your machine. Follow the link if Adafruit MicroPython is not already set up. Git helps keep downloads organized, so it\u2019s recommended to install it as well. Download it from - (Git Download","title":"Requiermantes"},{"location":"#connecting-the-solderbit","text":"The first step is to connect the SolderBit to the PC using a USB-C cable. If the \"Power\" LED turns on, it means the device is receiving power Connecting SolderBit","title":"Connecting the SolderBit"},{"location":"#downloading-the-source-code","text":"All of the source code written in MicroPython can be downloaded from Solderix API Repo . To download the repository, open a terminal in your chosen folder and run the following command: git clone https://github.com/Solderix/SolderBIT-API.git The folder structure of the root folder should look as follows: /bin /images /solderbit /examples /imports /newRadio flash_all_imports.bat flash_car.bat flash_controller.bat README.md","title":"Downloading the source code"},{"location":"#finding-the-solderbit-com-port","text":"To flash the SolderBit, its COM port must be identified. On Windows, open Device Manager and navigate to Ports (COM & LPT). The SolderBit usually appears as USB Serial Device (COMX), where X is a number. Example: USB Serial Device (COM29) Copy the COM number. Navigate to the downloaded source code folder and open flash_all_imports.bat with a text editor (Notepad or any other). Change the COM in the flash_all_imports.bat with the COM copied from the Device Manager. Save changes.","title":"Finding the SolderBit COM port"},{"location":"#running-the-script","text":"After completing the steps above, double-click flash_all_imports.bat . A terminal will open, and flashing will begin. This usually takes less than a minute. Once flashing is complete, a list of all imports will be displayed in the terminal. Example: /controller.py /expander.py /follower.py /gpio.py /microbit.py /oled.py /proxy.py /radio.py /sdcard.py /servo.py /srt.py /ultrasonic.py /vehicle.py","title":"Running the Script"},{"location":"#loading-the-main-program","text":"To load the main program, the ampy (Adafruit MicroPython) module is required. All programs are written in main.py . After writing your program, open a terminal in the folder where main.py is located. Then, enter the command: ampy -p COMx put main.py where COMx is the COM port of the Solderbit. . This command uploads main.py on the Solderbit, and after a hardware reset the program will run.","title":"Loading the main program"},{"location":"Controller_Example/","text":"Remote Controller Examples Remotes expand the input capabilities of the SolderBit. There are two versions of the Remote Controller: SRT: Simple remote transceiver with one joystick and two buttons. PRO: Advanced remote with two joysticks and nine additional buttons. The two remotes use different imports for proper operation, but both are designed to be as similar as possible for better compatibility. One change is needed when switching between remotes: the import method. Use import controller for the PRO version, and import srt as controller for the SRT version. Connecting the controller to Solderbit To connect the SolderBit to the remote, insert the SolderBit into the dedicated slot. Then, flick the switch on the right side of the remote down to the ON position. PRO SRT Reading Inputs Example Information All of the examples are written for the PRO version. To turn them into SRT version change import controller to import srt as controller . Each input can be read individually: from microbit import * import controller while True: print(controller.read_input(controller.LEFT_BTN)) print(controller.read_input(controller.RIGHT_BTN)) print(controller.read_input(controller.JOY_X1)) print(controller.read_input(controller.JOY_Y1)) print(controller.read_input(controller.JOY_X2)) print(controller.read_input(controller.JOY_Y2)) ### and so on... sleep(1000) Alternatively, all inputs can be read at once, then selectively accessed from the returned list. from microbit import * import controller while True: data = controller.read_all_inputs() #print out few values print(data[controller.LEFT_LEFT_BTN], data[controller.LEFT_RIGHT_BTN], data[controller.LEFT_UP_BTN], data[controller.LEFT_DOWN_BTN]) #or print the entire list print(data) sleep(1000) When transmitting data over the radio, it\u2019s best to use the encoded method. This reduces the memory used by inputs by packing them into a bytearray: from microbit import * import controller while True: encoded_data = controller.read_encoded() #Print out the bytearray print(encoded_data) Encoded data can be decoded Transmitter Example This example shows how to turn the controller into a simple transmitter. It selects a radio channel, reads the button states from the controller inputs, and sends the data over the radio to any listeners. PRO from microbit import * import radio import controller radio.config(group=8) radio.on() while True: radio.send_bytes(controller.read_encoded()) sleep(50) SRT from microbit import * import radio import srt as controller radio.config(group=8) radio.on() while True: radio.send_bytes(controller.read_encoded()) sleep(50) One Player Pong Example This example requires the Controller PRO and Solderbit PRO to work. from machine import Pin, SPI from microbit import * import random import st7789 import framebuf import controller width, height = 128, 64 buffer = bytearray(width * height * 2) # 2 bytes per pixel (RGB565) fb = framebuf.FrameBuffer(buffer, width, height, framebuf.RGB565) def config(rotation=0, buffer_size=0, options=0): return st7789.ST7789( SPI(2, baudrate=60_000_000, sck=Pin(18), mosi=Pin(14)), 128, 160, reset=Pin(46, Pin.OUT), cs=Pin(39, Pin.OUT), dc=Pin(16, Pin.OUT), backlight=Pin(47, Pin.OUT), color_order=st7789.RGB, rotation=rotation, buffer_size = 64*64*2, inversion=False) tft = config(1) tft.init() tft.fill(st7789.BLACK) left_score = 0 right_score = 0 player_one_pos = 28 player_two_pos = 28 player_length = 10 player_speed = 10 ball_x_pos = 62 ball_y_pos = 30 ball_x_vel = -3 ball_y_vel = 3 ball_steady = True steady_counter = 0 def draw_setup(): fb.text(str(left_score), 28, 5) fb.text(str(right_score), 95, 5) fb.line(64, 0, 64, 63, st7789.WHITE) for i in range(10): fb.line(64, 4+(i*10), 64, 9+(i*10), st7789.BLACK) return def draw_players(): for i in range(3): fb.line(2+i, player_one_pos, 2+i, player_one_pos+player_length, st7789.WHITE) fb.line(125+i, player_two_pos, 125+i, player_two_pos+player_length, st7789.WHITE) def draw_ball(): for i in range(4): fb.line(ball_x_pos+i, ball_y_pos, ball_x_pos+i, ball_y_pos+3, st7789.WHITE) def move_player_one(inputs): global player_one_pos global player_length global player_speed player_one_pos = player_one_pos + int(player_speed*(inputs[controller.JOY_Y1]/-700)) if player_one_pos < 0: player_one_pos = 0 if player_one_pos > 64-player_length: player_one_pos = 64-player_length def move_player_AI(): global player_two_pos global player_length global player_speed if ball_y_pos > (player_two_pos-2) and (player_two_pos+player_length)<ball_y_pos: player_two_pos = player_two_pos + 3 elif ball_y_pos < player_two_pos and (player_two_pos+player_length-2)>ball_y_pos: player_two_pos = player_two_pos - 3 if player_two_pos < 0: player_two_pos = 0 if player_two_pos > 64-player_length: player_two_pos = 64-player_length def move_ball(): global ball_x_pos global ball_y_pos global ball_x_vel global ball_y_vel global left_score global right_score global steady_counter if steady_counter < 40: steady_counter = steady_counter + 1 gain = random.randint(1,5) ball_x_vel = -(6-gain) ball_y_vel = gain return ball_x_pos = ball_x_pos + ball_x_vel ball_y_pos = ball_y_pos + ball_y_vel if ball_x_pos < 0: steady_counter = 0 right_score = right_score + 1 if ball_x_pos > 127: steady_counter = 0 left_score = left_score + 1 if steady_counter == 0: ball_y_pos = 30 ball_x_pos = 62 if ball_y_pos < 0 or ball_y_pos > 63: ball_y_pos = ball_y_pos - ball_y_vel*2 ball_y_vel = -ball_y_vel def detect_colision(): global ball_x_pos global ball_x_vel global ball_y_pos global ball_y_vel gain = random.randint(1,5) if ((ball_y_pos > player_two_pos and ball_y_pos < player_two_pos+player_length) or (((ball_y_pos+3) > player_two_pos and (ball_y_pos+3) < player_two_pos+player_length))) and ball_x_pos >= 122: ball_x_pos = ball_x_pos - ball_x_vel*2 ball_x_vel = -(6-gain) ball_y_vel = int(-(ball_y_vel/ball_y_vel)) * (gain) if ((ball_y_pos > player_one_pos and ball_y_pos < player_one_pos+player_length) or (((ball_y_pos+3) > player_one_pos and (ball_y_pos+3) < player_one_pos+player_length))) and ball_x_pos <= 6: ball_x_pos = ball_x_pos - ball_x_vel*2 ball_x_vel = (6-gain) ball_y_vel = int(-(ball_y_vel/ball_y_vel)) * (gain) def play_state(): global left_score, right_score inputs = controller.read_all_inputs() detect_colision() move_player_one(inputs) move_player_AI() move_ball() draw_setup() draw_players() draw_ball() if left_score == 12 or right_score == 12: return 2 if pin2.read_digital() == False: while pin2.read_digital() == False: pass left_score = 0 right_score = 1 return 2 return 1 def start_state(): fb.text(\"Press start\", 20, 20, st7789.WHITE) fb.text(\"for a new game\", 9, 30, st7789.WHITE) if pin2.read_digital() == False: while pin2.read_digital() == False: pass return 1 return 0 def game_over_state(): global left_score, right_score global player_one_pos, player_two_pos, player_length, player_speed global ball_x_pos, ball_y_pos, ball_x_vel, ball_y_vel, ball_steady, steady_counter if left_score > right_score: fb.text(\"You win!\", 23, 20, st7789.WHITE) else: fb.text(\"Game over\", 23, 20, st7789.WHITE) sleep(2000) left_score = 0 right_score = 0 player_one_pos = 28 player_two_pos = 28 player_length = 10 player_speed = 10 ball_x_pos = 62 ball_y_pos = 30 ball_x_vel = -3 ball_y_vel = 3 ball_steady = True steady_counter = 0 def state_machine(state): fb.fill(st7789.BLACK) out = state if state == 0: out = start_state() elif state == 1: out = play_state() elif state == 2: game_over_state() out = 0 tft.rect(15, 31, width+4, height+2, st7789.WHITE) tft.blit_buffer(buffer, 16, 32, width, height) return out states = 0 while True: states = state_machine(states) sleep(5)","title":"Controller Examples"},{"location":"Controller_Example/#remote-controller-examples","text":"Remotes expand the input capabilities of the SolderBit. There are two versions of the Remote Controller: SRT: Simple remote transceiver with one joystick and two buttons. PRO: Advanced remote with two joysticks and nine additional buttons. The two remotes use different imports for proper operation, but both are designed to be as similar as possible for better compatibility. One change is needed when switching between remotes: the import method. Use import controller for the PRO version, and import srt as controller for the SRT version.","title":"Remote Controller Examples"},{"location":"Controller_Example/#connecting-the-controller-to-solderbit","text":"To connect the SolderBit to the remote, insert the SolderBit into the dedicated slot. Then, flick the switch on the right side of the remote down to the ON position.","title":"Connecting the controller to Solderbit"},{"location":"Controller_Example/#pro","text":"","title":"PRO"},{"location":"Controller_Example/#srt","text":"","title":"SRT"},{"location":"Controller_Example/#reading-inputs-example","text":"Information All of the examples are written for the PRO version. To turn them into SRT version change import controller to import srt as controller . Each input can be read individually: from microbit import * import controller while True: print(controller.read_input(controller.LEFT_BTN)) print(controller.read_input(controller.RIGHT_BTN)) print(controller.read_input(controller.JOY_X1)) print(controller.read_input(controller.JOY_Y1)) print(controller.read_input(controller.JOY_X2)) print(controller.read_input(controller.JOY_Y2)) ### and so on... sleep(1000) Alternatively, all inputs can be read at once, then selectively accessed from the returned list. from microbit import * import controller while True: data = controller.read_all_inputs() #print out few values print(data[controller.LEFT_LEFT_BTN], data[controller.LEFT_RIGHT_BTN], data[controller.LEFT_UP_BTN], data[controller.LEFT_DOWN_BTN]) #or print the entire list print(data) sleep(1000) When transmitting data over the radio, it\u2019s best to use the encoded method. This reduces the memory used by inputs by packing them into a bytearray: from microbit import * import controller while True: encoded_data = controller.read_encoded() #Print out the bytearray print(encoded_data) Encoded data can be decoded","title":"Reading Inputs Example"},{"location":"Controller_Example/#transmitter-example","text":"This example shows how to turn the controller into a simple transmitter. It selects a radio channel, reads the button states from the controller inputs, and sends the data over the radio to any listeners.","title":"Transmitter Example"},{"location":"Controller_Example/#pro_1","text":"from microbit import * import radio import controller radio.config(group=8) radio.on() while True: radio.send_bytes(controller.read_encoded()) sleep(50)","title":"PRO"},{"location":"Controller_Example/#srt_1","text":"from microbit import * import radio import srt as controller radio.config(group=8) radio.on() while True: radio.send_bytes(controller.read_encoded()) sleep(50)","title":"SRT"},{"location":"Controller_Example/#one-player-pong-example","text":"This example requires the Controller PRO and Solderbit PRO to work. from machine import Pin, SPI from microbit import * import random import st7789 import framebuf import controller width, height = 128, 64 buffer = bytearray(width * height * 2) # 2 bytes per pixel (RGB565) fb = framebuf.FrameBuffer(buffer, width, height, framebuf.RGB565) def config(rotation=0, buffer_size=0, options=0): return st7789.ST7789( SPI(2, baudrate=60_000_000, sck=Pin(18), mosi=Pin(14)), 128, 160, reset=Pin(46, Pin.OUT), cs=Pin(39, Pin.OUT), dc=Pin(16, Pin.OUT), backlight=Pin(47, Pin.OUT), color_order=st7789.RGB, rotation=rotation, buffer_size = 64*64*2, inversion=False) tft = config(1) tft.init() tft.fill(st7789.BLACK) left_score = 0 right_score = 0 player_one_pos = 28 player_two_pos = 28 player_length = 10 player_speed = 10 ball_x_pos = 62 ball_y_pos = 30 ball_x_vel = -3 ball_y_vel = 3 ball_steady = True steady_counter = 0 def draw_setup(): fb.text(str(left_score), 28, 5) fb.text(str(right_score), 95, 5) fb.line(64, 0, 64, 63, st7789.WHITE) for i in range(10): fb.line(64, 4+(i*10), 64, 9+(i*10), st7789.BLACK) return def draw_players(): for i in range(3): fb.line(2+i, player_one_pos, 2+i, player_one_pos+player_length, st7789.WHITE) fb.line(125+i, player_two_pos, 125+i, player_two_pos+player_length, st7789.WHITE) def draw_ball(): for i in range(4): fb.line(ball_x_pos+i, ball_y_pos, ball_x_pos+i, ball_y_pos+3, st7789.WHITE) def move_player_one(inputs): global player_one_pos global player_length global player_speed player_one_pos = player_one_pos + int(player_speed*(inputs[controller.JOY_Y1]/-700)) if player_one_pos < 0: player_one_pos = 0 if player_one_pos > 64-player_length: player_one_pos = 64-player_length def move_player_AI(): global player_two_pos global player_length global player_speed if ball_y_pos > (player_two_pos-2) and (player_two_pos+player_length)<ball_y_pos: player_two_pos = player_two_pos + 3 elif ball_y_pos < player_two_pos and (player_two_pos+player_length-2)>ball_y_pos: player_two_pos = player_two_pos - 3 if player_two_pos < 0: player_two_pos = 0 if player_two_pos > 64-player_length: player_two_pos = 64-player_length def move_ball(): global ball_x_pos global ball_y_pos global ball_x_vel global ball_y_vel global left_score global right_score global steady_counter if steady_counter < 40: steady_counter = steady_counter + 1 gain = random.randint(1,5) ball_x_vel = -(6-gain) ball_y_vel = gain return ball_x_pos = ball_x_pos + ball_x_vel ball_y_pos = ball_y_pos + ball_y_vel if ball_x_pos < 0: steady_counter = 0 right_score = right_score + 1 if ball_x_pos > 127: steady_counter = 0 left_score = left_score + 1 if steady_counter == 0: ball_y_pos = 30 ball_x_pos = 62 if ball_y_pos < 0 or ball_y_pos > 63: ball_y_pos = ball_y_pos - ball_y_vel*2 ball_y_vel = -ball_y_vel def detect_colision(): global ball_x_pos global ball_x_vel global ball_y_pos global ball_y_vel gain = random.randint(1,5) if ((ball_y_pos > player_two_pos and ball_y_pos < player_two_pos+player_length) or (((ball_y_pos+3) > player_two_pos and (ball_y_pos+3) < player_two_pos+player_length))) and ball_x_pos >= 122: ball_x_pos = ball_x_pos - ball_x_vel*2 ball_x_vel = -(6-gain) ball_y_vel = int(-(ball_y_vel/ball_y_vel)) * (gain) if ((ball_y_pos > player_one_pos and ball_y_pos < player_one_pos+player_length) or (((ball_y_pos+3) > player_one_pos and (ball_y_pos+3) < player_one_pos+player_length))) and ball_x_pos <= 6: ball_x_pos = ball_x_pos - ball_x_vel*2 ball_x_vel = (6-gain) ball_y_vel = int(-(ball_y_vel/ball_y_vel)) * (gain) def play_state(): global left_score, right_score inputs = controller.read_all_inputs() detect_colision() move_player_one(inputs) move_player_AI() move_ball() draw_setup() draw_players() draw_ball() if left_score == 12 or right_score == 12: return 2 if pin2.read_digital() == False: while pin2.read_digital() == False: pass left_score = 0 right_score = 1 return 2 return 1 def start_state(): fb.text(\"Press start\", 20, 20, st7789.WHITE) fb.text(\"for a new game\", 9, 30, st7789.WHITE) if pin2.read_digital() == False: while pin2.read_digital() == False: pass return 1 return 0 def game_over_state(): global left_score, right_score global player_one_pos, player_two_pos, player_length, player_speed global ball_x_pos, ball_y_pos, ball_x_vel, ball_y_vel, ball_steady, steady_counter if left_score > right_score: fb.text(\"You win!\", 23, 20, st7789.WHITE) else: fb.text(\"Game over\", 23, 20, st7789.WHITE) sleep(2000) left_score = 0 right_score = 0 player_one_pos = 28 player_two_pos = 28 player_length = 10 player_speed = 10 ball_x_pos = 62 ball_y_pos = 30 ball_x_vel = -3 ball_y_vel = 3 ball_steady = True steady_counter = 0 def state_machine(state): fb.fill(st7789.BLACK) out = state if state == 0: out = start_state() elif state == 1: out = play_state() elif state == 2: game_over_state() out = 0 tft.rect(15, 31, width+4, height+2, st7789.WHITE) tft.blit_buffer(buffer, 16, 32, width, height) return out states = 0 while True: states = state_machine(states) sleep(5)","title":"One Player Pong Example"},{"location":"Mainboard_Example/","text":"Mainboard Vehicle Examples The mainboard is primarily used for vehicle controls. It has 7 built-in LED output pins (pin 7 includes a built-in LED), 2 DC motor drivers (each with 4 output pins), and two servo drivers. It also features an integrated buzzer, two QWIIC ports, and 2 power ports. To use the mainboard, a SolderBit needs to be inserted into the onboard slot. Simple Movement Examples The mainboard can be used as a robotic vehicle that follows a preprogrammed movement pattern or responds to user input. To set it up, ensure the DC motors are connected correctly and the board is receiving power via the power cable. Once the DC motors are connected and oriented properly, the mainboard can be used as a vehicle using the vehicle.move() function. vehicle.move() takes two mandatory arguments and one optional argument. The first two arguments set the speed for each direction, X and Y: The X and Y arguments accept values between -500 and 500, where 0 means no movement, 500 means maximum speed in the positive direction, and -500 means maximum speed in the negative direction. Currently, values between -20 and 20 are considered a dead zone, so no motor output occurs within this range. This may change in future updates. Rotate in one direction The following code demonstrates how to continuously rotate a vehicle in one direction at maximum speed. from microbit import * import vehicle while True: vehicle.move(500, 0) Rotate in both directions When preprogramming movement patterns with the vehicle module, the vehicle may need to maintain speed for a period before changing direction. Since the vehicle import filters inputs, a regular sleep() won\u2019t work. To enforce a delay, use the third argument of vehicle.move() . from microbit import * import vehicle while True: \"\"\" ***INCORRECT CODE*** vehicle.move(500, 0) sleep(1000) #Uses sleep to hold vehicle speed constant. vehicle.move(-500, 0) sleep(1000) \"\"\" \"\"\" ***CORRECT CODE*** \"\"\" vehicle.move(500, 0, 1000) vehicle.move(-500, 0, 1000) Back-and-forth Example from microbit import * import vehicle while True: vehicle.move(0, 500, 1000) vehicle.move(0, -500, 1000) Preprogramed Patterns The best way to implement a preprogrammed pattern is by using a nested list. from microbit import * import vehicle pattern = [ [500, 0, 1000], # Rotate right [-500, 0, 1000], # Rotate left [0, 500, 1000], # Move forward [0, -500, 1000], # Move backward [0, 0, 1000], # Stop ] while True: for move in pattern: vehicle.move(*move) #vehicle.move(move[0], move[1], move[2]) #This is also valid This isn\u2019t the only way to create preprogrammed patterns. They can also be implemented line by line, as shown in the following example: from microbit import * import vehicle while True: vehicle.move(500, 0, 1000) # Rotate right vehicle.move(-500, 0, 1000) # Rotate left vehicle.move(0, 500, 1000) # Move forward vehicle.move(, -500, 1000) # Move backward vehicle.move(0, 0, 1000) # Stop Remote Controlled Vehicle Example The most common way to use vehicles is with a remote controller. To enable this, flash the following code onto the SolderBit: from microbit import * import radio import vehicle import srt as controller radio.config(group=8) radio.on() vehicle.acceleration = 1.0 vehicle.speed = 1.0 _next_check = 0 _check_period = 250 while True: data = controller.data_decode(radio.receive_bytes()) if _next_check < running_time(): vehicle.move(0, 0) if data == None: continue _next_check = running_time() + _check_period vehicle.move(data[controller.JOY_X2], y = data[controller.JOY_Y1]) Make sure radio.config(group=8) is set to the same g group as on the controller. Additional Features Example Additional features of the mainboard include: LED Outputs Servo Drivers Buzzer Servo drivers will be explained in the PWM Examples. LED Driver The LED driver can be controlled using vehicle.set_outputs() , which accepts 7 arguments\u2014one for each output: l0 l1 l2 l3 l4 l5 l6 connected Following example will show how to blink a single LED output: from microbit import * import vehicle while True: vehicle.set_outputs(l0=1) sleep(1000) vehicle.set_outputs(l0=0) sleep(1000) Buzzer Buzzer can be used by calling the vehicle.horn() function. Passing a 1 will turn the buzzer on, passing a 0 will turn it off. from microbit import * import vehicle while True: vehicle.horn(1) sleep(1000) vehicle.horn(0) sleep(1000)","title":"Mainboard Examples"},{"location":"Mainboard_Example/#mainboard-vehicle-examples","text":"The mainboard is primarily used for vehicle controls. It has 7 built-in LED output pins (pin 7 includes a built-in LED), 2 DC motor drivers (each with 4 output pins), and two servo drivers. It also features an integrated buzzer, two QWIIC ports, and 2 power ports. To use the mainboard, a SolderBit needs to be inserted into the onboard slot.","title":"Mainboard Vehicle Examples"},{"location":"Mainboard_Example/#simple-movement-examples","text":"The mainboard can be used as a robotic vehicle that follows a preprogrammed movement pattern or responds to user input. To set it up, ensure the DC motors are connected correctly and the board is receiving power via the power cable. Once the DC motors are connected and oriented properly, the mainboard can be used as a vehicle using the vehicle.move() function. vehicle.move() takes two mandatory arguments and one optional argument. The first two arguments set the speed for each direction, X and Y: The X and Y arguments accept values between -500 and 500, where 0 means no movement, 500 means maximum speed in the positive direction, and -500 means maximum speed in the negative direction. Currently, values between -20 and 20 are considered a dead zone, so no motor output occurs within this range. This may change in future updates.","title":"Simple Movement Examples"},{"location":"Mainboard_Example/#rotate-in-one-direction","text":"The following code demonstrates how to continuously rotate a vehicle in one direction at maximum speed. from microbit import * import vehicle while True: vehicle.move(500, 0)","title":"Rotate in one direction"},{"location":"Mainboard_Example/#rotate-in-both-directions","text":"When preprogramming movement patterns with the vehicle module, the vehicle may need to maintain speed for a period before changing direction. Since the vehicle import filters inputs, a regular sleep() won\u2019t work. To enforce a delay, use the third argument of vehicle.move() . from microbit import * import vehicle while True: \"\"\" ***INCORRECT CODE*** vehicle.move(500, 0) sleep(1000) #Uses sleep to hold vehicle speed constant. vehicle.move(-500, 0) sleep(1000) \"\"\" \"\"\" ***CORRECT CODE*** \"\"\" vehicle.move(500, 0, 1000) vehicle.move(-500, 0, 1000)","title":"Rotate in both directions"},{"location":"Mainboard_Example/#back-and-forth-example","text":"from microbit import * import vehicle while True: vehicle.move(0, 500, 1000) vehicle.move(0, -500, 1000)","title":"Back-and-forth Example"},{"location":"Mainboard_Example/#preprogramed-patterns","text":"The best way to implement a preprogrammed pattern is by using a nested list. from microbit import * import vehicle pattern = [ [500, 0, 1000], # Rotate right [-500, 0, 1000], # Rotate left [0, 500, 1000], # Move forward [0, -500, 1000], # Move backward [0, 0, 1000], # Stop ] while True: for move in pattern: vehicle.move(*move) #vehicle.move(move[0], move[1], move[2]) #This is also valid This isn\u2019t the only way to create preprogrammed patterns. They can also be implemented line by line, as shown in the following example: from microbit import * import vehicle while True: vehicle.move(500, 0, 1000) # Rotate right vehicle.move(-500, 0, 1000) # Rotate left vehicle.move(0, 500, 1000) # Move forward vehicle.move(, -500, 1000) # Move backward vehicle.move(0, 0, 1000) # Stop","title":"Preprogramed Patterns"},{"location":"Mainboard_Example/#remote-controlled-vehicle-example","text":"The most common way to use vehicles is with a remote controller. To enable this, flash the following code onto the SolderBit: from microbit import * import radio import vehicle import srt as controller radio.config(group=8) radio.on() vehicle.acceleration = 1.0 vehicle.speed = 1.0 _next_check = 0 _check_period = 250 while True: data = controller.data_decode(radio.receive_bytes()) if _next_check < running_time(): vehicle.move(0, 0) if data == None: continue _next_check = running_time() + _check_period vehicle.move(data[controller.JOY_X2], y = data[controller.JOY_Y1]) Make sure radio.config(group=8) is set to the same g group as on the controller.","title":"Remote Controlled Vehicle Example"},{"location":"Mainboard_Example/#additional-features-example","text":"Additional features of the mainboard include: LED Outputs Servo Drivers Buzzer Servo drivers will be explained in the PWM Examples.","title":"Additional Features Example"},{"location":"Mainboard_Example/#led-driver","text":"The LED driver can be controlled using vehicle.set_outputs() , which accepts 7 arguments\u2014one for each output: l0 l1 l2 l3 l4 l5 l6 connected Following example will show how to blink a single LED output: from microbit import * import vehicle while True: vehicle.set_outputs(l0=1) sleep(1000) vehicle.set_outputs(l0=0) sleep(1000)","title":"LED Driver"},{"location":"Mainboard_Example/#buzzer","text":"Buzzer can be used by calling the vehicle.horn() function. Passing a 1 will turn the buzzer on, passing a 0 will turn it off. from microbit import * import vehicle while True: vehicle.horn(1) sleep(1000) vehicle.horn(0) sleep(1000)","title":"Buzzer"},{"location":"OLED_Example/","text":"Organic Light-Emmiting Diode Display A monochromatic graphical display used for drawing shapes and text. To use the OLED display with the Solderix platform, an Adapter Board is required. Make sure the pins of the OLED and Adapter Board are properly aligned. Hello World from microbit import * import oled oled.rotate(2) oled.text(\"Hello World\", 0, 0) oled.show() Rotate Display This example demonstrates how to rotate the display and explains each rotation. from microbit import * import oled while True: for rot in range(4): oled.rotate(rot) oled.text(\"Hello World\", 0, 0) oled.show() sleep(250) Invert Display Displayed pixels can be inverted, turning all off pixels on and all on pixels off. from microbit import * import oled oled.text(\"Hello World\", 0, 0) oled.invert(0) oled.show() sleep(1000) oled.invert(1) Draw Shapes The OLED can also be used to draw shapes. Predefined shapes include: Line Rectangle Filled Rectangle Circle Filled Circle from microbit import * import oled oled.rotate(2) # Set rotation to 0 degrees while True: oled.fill(0) #Clear the display for num in range(8): oled.line(0, 0, 127, num*8, 1) # Draw lines oled.show() sleep(1) oled.fill(0) #Clear the display oled.rect(20,20,10,10, 1, False) # Draw empty rect oled.show() sleep(1000) oled.fill(0) #Clear the display oled.rect(30,30,20,20, 1, True) # Draw filled rect oled.show() sleep(1000) oled.fill(0) #Clear the display oled.circle(20,20,10, 1, False) # Draw empty circle oled.show() sleep(1000) oled.fill(0) #Clear the display oled.circle(30,30,20, 1, True) # Draw filled circle oled.show() sleep(1000)","title":"OLED Display Examples"},{"location":"OLED_Example/#organic-light-emmiting-diode-display","text":"A monochromatic graphical display used for drawing shapes and text. To use the OLED display with the Solderix platform, an Adapter Board is required. Make sure the pins of the OLED and Adapter Board are properly aligned.","title":"Organic Light-Emmiting Diode Display"},{"location":"OLED_Example/#hello-world","text":"from microbit import * import oled oled.rotate(2) oled.text(\"Hello World\", 0, 0) oled.show()","title":"Hello World"},{"location":"OLED_Example/#rotate-display","text":"This example demonstrates how to rotate the display and explains each rotation. from microbit import * import oled while True: for rot in range(4): oled.rotate(rot) oled.text(\"Hello World\", 0, 0) oled.show() sleep(250)","title":"Rotate Display"},{"location":"OLED_Example/#invert-display","text":"Displayed pixels can be inverted, turning all off pixels on and all on pixels off. from microbit import * import oled oled.text(\"Hello World\", 0, 0) oled.invert(0) oled.show() sleep(1000) oled.invert(1)","title":"Invert Display"},{"location":"OLED_Example/#draw-shapes","text":"The OLED can also be used to draw shapes. Predefined shapes include: Line Rectangle Filled Rectangle Circle Filled Circle from microbit import * import oled oled.rotate(2) # Set rotation to 0 degrees while True: oled.fill(0) #Clear the display for num in range(8): oled.line(0, 0, 127, num*8, 1) # Draw lines oled.show() sleep(1) oled.fill(0) #Clear the display oled.rect(20,20,10,10, 1, False) # Draw empty rect oled.show() sleep(1000) oled.fill(0) #Clear the display oled.rect(30,30,20,20, 1, True) # Draw filled rect oled.show() sleep(1000) oled.fill(0) #Clear the display oled.circle(20,20,10, 1, False) # Draw empty circle oled.show() sleep(1000) oled.fill(0) #Clear the display oled.circle(30,30,20, 1, True) # Draw filled circle oled.show() sleep(1000)","title":"Draw Shapes"},{"location":"PWM_Example/","text":"Pulse Width Modulation Examples The PWM module is used for analog output functions and servo motor control. The motherboard also has two PWM ports that don\u2019t require the PWM module. Onboard PWM Example This example uses the onboard PWM pins to drive a servo motor from 0 to 180 degrees and back to 0. It uses a single servo motor connected to output header 0. from microbit import * import servo for deg in range(180): servo.turn(servo.front, deg, True) for deg in range(180): servo.turn(servo.front, 180-deg, True) Instead of the front servo, the back servo can be used. This is achieved by using the servo.back . from microbit import * import servo for deg in range(180): servo.turn(servo.back, deg, True) for deg in range(180): servo.turn(servo.back, 180-deg, True) PWM Module Example Make sure the PWM module is connected to the motherboard via the QWIIC cable and that the power cable is also connected. The QWIIC cable also needs to be connected to the mainboard. This example rotates a servo motor from 0 to 180 degrees and then back to 0. It uses a single servo motor connected to output header 0. from microbit import * import servo servo_pin = 0 for deg in range(180): servo.turn(servo_pin, deg, True) sleep(1) for deg in range(180): servo.turn(servo_pin, 180-deg, True) sleep(1) sleep(1000) To change the output on the PWM module just change the servo_pin to any value between 0 and 15. The servo_pin does not need to be used in this way to control a servo motor. Value can be passed directly into the servo.turn() function: from microbit import * import servo servo.turn(0, 0, True) sleep(250) servo.turn(1, 10, True) sleep(250) servo.turn(2, 20, True) sleep(250) servo.turn(3, 30, True) sleep(250) Servo Vehicle Example This example modifies the regular Vehicle Example to use a servo motor for steering. It uses the onboard front servo driver, so no PWM module is required. from microbit import * import radio import vehicle import srt as controller import servo radio.config(group=5) radio.on() vehicle.acceleration = 1.0 vehicle.speed = 1.0 _next_check = 0 _check_period = 250 x_pev = 0 while True: data = controller.data_decode(radio.receive_bytes()) if data != None: print(data) x = data[controller.JOY_X2] y = data[controller.JOY_Y1] if x < 100 and x > -100: x = 0 if y < 20 and y > -20: y = 0 servo.turn(servo.front, scale(x, (-500, 500), (70,108)), True) _next_check = running_time() + _check_period vehicle.move(0, y) if _next_check < running_time(): servo.turn(servo.front, scale(0, (-500, 500), (65,113)), True) vehicle.move(0, 0)","title":"PWM Module Examples"},{"location":"PWM_Example/#pulse-width-modulation-examples","text":"The PWM module is used for analog output functions and servo motor control. The motherboard also has two PWM ports that don\u2019t require the PWM module.","title":"Pulse Width Modulation Examples"},{"location":"PWM_Example/#onboard-pwm-example","text":"This example uses the onboard PWM pins to drive a servo motor from 0 to 180 degrees and back to 0. It uses a single servo motor connected to output header 0. from microbit import * import servo for deg in range(180): servo.turn(servo.front, deg, True) for deg in range(180): servo.turn(servo.front, 180-deg, True) Instead of the front servo, the back servo can be used. This is achieved by using the servo.back . from microbit import * import servo for deg in range(180): servo.turn(servo.back, deg, True) for deg in range(180): servo.turn(servo.back, 180-deg, True)","title":"Onboard PWM Example"},{"location":"PWM_Example/#pwm-module-example","text":"Make sure the PWM module is connected to the motherboard via the QWIIC cable and that the power cable is also connected. The QWIIC cable also needs to be connected to the mainboard. This example rotates a servo motor from 0 to 180 degrees and then back to 0. It uses a single servo motor connected to output header 0. from microbit import * import servo servo_pin = 0 for deg in range(180): servo.turn(servo_pin, deg, True) sleep(1) for deg in range(180): servo.turn(servo_pin, 180-deg, True) sleep(1) sleep(1000) To change the output on the PWM module just change the servo_pin to any value between 0 and 15. The servo_pin does not need to be used in this way to control a servo motor. Value can be passed directly into the servo.turn() function: from microbit import * import servo servo.turn(0, 0, True) sleep(250) servo.turn(1, 10, True) sleep(250) servo.turn(2, 20, True) sleep(250) servo.turn(3, 30, True) sleep(250)","title":"PWM Module Example"},{"location":"PWM_Example/#servo-vehicle-example","text":"This example modifies the regular Vehicle Example to use a servo motor for steering. It uses the onboard front servo driver, so no PWM module is required. from microbit import * import radio import vehicle import srt as controller import servo radio.config(group=5) radio.on() vehicle.acceleration = 1.0 vehicle.speed = 1.0 _next_check = 0 _check_period = 250 x_pev = 0 while True: data = controller.data_decode(radio.receive_bytes()) if data != None: print(data) x = data[controller.JOY_X2] y = data[controller.JOY_Y1] if x < 100 and x > -100: x = 0 if y < 20 and y > -20: y = 0 servo.turn(servo.front, scale(x, (-500, 500), (70,108)), True) _next_check = running_time() + _check_period vehicle.move(0, y) if _next_check < running_time(): servo.turn(servo.front, scale(0, (-500, 500), (65,113)), True) vehicle.move(0, 0)","title":"Servo Vehicle Example"},{"location":"imports/","text":"Imports This section contains all imports made by Solderix and goes through every function each module has. OLED The OLED is a monochromatic display with dimensions of 128\u00d764. To interface with it, a Solderix Adapter board is required. When calling import oled the display will automatically configure itself and turn on. poweroff Definiton - poweroff() -> None Description - Powers off the display. Parameters - None Returns - None contrast Definiton - contrast(contrast) -> None Description - Changes the pixel contrast. Parameters - contrast (byte): amount of contrast. Returns - None invert Definiton - invert(invert) -> None Description - Inverts or reverts pixels on the display. Parameters - invert (byte): 0 is non inverted, 1 is inverted. Returns - None show Definiton - show() -> None Description - When writing to the display, pixels are first stored in an internal buffer. This avoids flickering caused by writing directly to the display. The entire buffer is then sent as one image. This function pushes that image to the display. from microbit import * import oled oled.text(\"test\",0,0) # will not be displayed oled.line(0,0, 128,64) # will not be displayed oled.show() # after this text and line will be displayed Parameters - None Returns - None fill Definiton - fill(col) -> None Description - Fills the entire screen with a colour. Parameters - col (byte): 0 is no colour, 1 is colour on. Returns - None pixel Definiton - pixel(x,y,col) -> None Description - Draws a pixel at the given coordinates. Parameters: x (int): width coordinate. y (int): height coordinate. col (int): 0 is colour off, 1 is colour on. Returns - None text Definiton - text(string,x,y,col) -> None Description - Draws a string to the display. Parameters: string (string): string to be drawn. x (int): width coordinate. y (int): height coordinate. col (int): 0 is colour off, 1 is colour on. Returns - None bitmap Definiton - bitmap(buf,x,y,w,h) -> None Description - Draws a bitmap to the display. The bitmap is blitted, so when creating a custom bitmap, make sure to adhere to the padding standards. Parameters: buf (list): buffer that contains the bitmap. x (int): width coordinate. y (int): height coordinate. w (int): width. h (int): height. Returns - None line Definiton - line(x1, y1, x2, y2, c) -> None Description - Draws a line to the display. Parameters: x1 (int): width coordinate for line start. y1 (int): heigth coordinate for line start. x2 (int): width coordinate for line end. y2 (int): height coordinate for line end. c (int): 0 is colour off, 1 is colour on. Returns - None rect Definiton - rect(x,y,w,h,c,f) -> None Description - Draws a rectangle to the display. Parameters: x (int): width coordinate for rectangle start. y (int): height coordinate for rectangle start. w (int): rectangle width. h (int): rectangle height. c (int): 0 is colour off, 1 is colour on. f (bool): 0 will keep the rectangle empty, 1 will fill the rectangle Returns - None circle Definiton - circle(x,y,r,c,f) -> None Description - Draws a circle to the display. Parameters: x (int): width coordinate for circle start. y (int): height coordinate for circle start. r (int): circle radius. c (int): 0 is colour off, 1 is colour on. f (bool): 0 will keep the circle empty, 1 will fill the circle. Returns - None Proximity Sensor used to measure light intensity in lux and approximate object distance at short range. lux Definiton - lux() -> float Description - Function that returns ambient light measurment. Parameters: - None Returns - Ambient light in lux. Returns None if no measurement was made. detect Definiton - detect() -> int Description - Function used for object detection. The lower the return value, the farther the object. Since measurements can be inaccurate due to color effects, the return value represents intensity rather than exact distance. Parameters: - None Returns - Detected distance intensity. Servo Used for controlling the motherboard servo as well as the servo add-on. When calling import servo the module will automatically configure itself and turn on. Definitions The module has two definitions, each corresponding to a servo pin on the Solderix Motherboard. front (pin): Servo on the front of the motherboard. back (pin): Servo on the back of the motherboard. Example: from microbit import * import servo for deg in range(180): servo.turn(servo.front, deg, True) turn Definiton - turn(servo, value, convert=True) -> None Description Turns the servo to a desired position between 0 and 180 degrees. The range of the value parameter depends on the convert flag: If convert is True , value should be between 0 and 180, which is internally converted to a range of 90 to 500. If convert is False , value should already be in the range 90 to 500. Parameters: servo (int): servo to be set. Range goes from 0 to 15. value (int): position of the servo. convert (bool): sets conversion of the value parameter. Returns - None Expander Used to expand the QWIIC ports on the SolderBit. When calling import expander the module will automatically configure itself and turn on. select Definiton - select(channel) -> None Description - Turns one QWIIC port into 4 seperate QWIIC buses. Parameters: - channel (int): channel from 0 to 3. Returns - None GPIO Used for expanding the SolderBit inputs and outputs. Definitions The module has four definitions: two for pin configuration and two for output logic levels. INPUT (int): sets pin as input. OUTPUT (int): sets pin as output. LOW (int): sets output low. HIGH (int): sets output low high. mode Definiton - mode(pin,mode) -> None Description - Configures a pin as input or output. To set it, use the INPUT and OUTPUT definitions. Parameters: pin (int): Pin number from 0 to 15. mode (int): IO mode (input/output). Returns - None read Definiton - read(pin) -> int Description - If the pin is configured as an INPUT , it reads to logic level of the pin. Parameters: pin (int): Pin number from 0 to 15. Returns - 0 for logic level low, and 1 for logic level high. write Definiton - read(pin,state) -> None Description - If the pin is configured as an OUTPUT , writes a logic level to the pin. Parameters: pin (int): Pin number from 0 to 15. state (int): logic level. Use LOW and HIGH definitions. Returns - None Ultrasonic Ultrasonic. distance Definiton - distance() -> int Description - Returns the distance to an object in centimetres. Parameters - None Returns - Returns the distance to an object in centimetres. Follower Infrared line follower. read Definiton - read(channel) -> int Description - Reads the intensity from the infrared sensor on the selected channel. Parameters - channel (int): channel to read ranging from 0 to 3. Returns - Returns the IR intensity. Controller Module for the Joystick PRO. Definitions Module has sixteen definitions, one for every input: JOY_X1 (int): left joystick input x. JOY_Y1 (int): left joystick input y. JOY_X2 (int): right joystick input x. JOY_Y2 (int): right joystick input y. JOY1_BTN (int): left joystick button. JOY2_BTN (int): right joystick button. R1_BTN (int): right side switch. L1_BTN (int): left side switch. LEFT_UP_BTN (int): left cluster upper button. LEFT_DOWN_BTN (int): left cluster lower button. LEFT_RIGHT_BTN (int): left cluster right button. LEFT_LEFT_BTN (int): left cluster left button. RIGHT_UP_BTN (int): right cluster upper button. RIGHT_DOWN_BTN (int): right cluster lower button. RIGHT_RIGHT_BTN (int): right cluster right button. RIGHT_LEFT_BTN (int): right cluster left button. read_input Definiton - read_input(input, offset=True) -> int, bool Description - Reads the specified input from the joystick. Parameters - input (int): input to be read. - offset (bool): used for joystick center offestting. If set to true the rading will be offset to the center of the joystick. Returns - Returns an integer if reading a joystick, and a bool if reading a button. read_all_inputs Definiton - read_all_inputs() -> list Description - This function reads all inputs and returns them as a list. The list can be accessed using the input definitions provided by the module. Parameters - input (int): input to be read. - offset (bool): used for joystick center offestting. If set to true the rading will be offset to the center of the joystick. Returns - Returns an integer if reading a joystick, and a bool if reading a button. read_encoded Definiton - read_encoded() -> bytearray Description - Reads all inputs and encodes them in a bytearray. Parameters - None Returns - Encoded bytearray. data_decode Definiton - data_decode(data) -> list Description - Decodes an encoded bytearray. Parameters - data (bytearray): data to be decoded. Returns - Decoded data. SRT Module for the Joystick SRT. Definitions Module has sixteen definitions, one for every input: JOY_X1 (int): left joystick input x. JOY_Y1 (int): left joystick input y. JOY_X2 (int): right joystick input x. JOY_Y2 (int): right joystick input y. JOY1_BTN (int): left joystick button. JOY2_BTN (int): right joystick button. R1_BTN (int): right side switch. L1_BTN (int): left side switch. LEFT_UP_BTN (int): left cluster upper button. LEFT_DOWN_BTN (int): left cluster lower button. LEFT_RIGHT_BTN (int): left cluster right button. LEFT_LEFT_BTN (int): left cluster left button. RIGHT_UP_BTN (int): right cluster upper button. RIGHT_DOWN_BTN (int): right cluster lower button. RIGHT_RIGHT_BTN (int): right cluster right button. RIGHT_LEFT_BTN (int): right cluster left button. read_all_inputs Definiton - read_all_inputs() -> list Description - This function reads all inputs and returns them as a list. The list can be accessed using the input definitions provided by the module. Parameters input (int): input to be read. offset (bool): used for joystick center offestting. If set to true the rading will be offset to the center of the joystick. Returns - Returns an integer if reading a joystick, and a bool if reading a button. read_encoded Definiton - read_encoded() -> bytearray Description - Reads all inputs and encodes them in a bytearray. Parameters - None Returns - Encoded bytearray. data_decode Definiton - data_decode(data) -> list Description - Decodes an encoded bytearray. Parameters - data (bytearray): data to be decoded. Returns - Decoded data. Vehicle Module for vehicle controls. Globals acceleration (float): Sets the acceleration rate of the vehicle from 0.0 to 1.0 in increments of 0.01. speed (float): Sets the speed rate of the vehicle from 0.0 to 1.0 in increments of 0.01. move Definiton - move(x,y,delay) -> None Description - Reads the encoded bytearray and. Parameters x (int): horizintal movement. y (int): vertical movement. delay (int): how long should the function block for. Returns - None set_outputs Definiton - set_outputs(connect, l6, l5, l4, l3, l2, l1, l0) -> None Description - Sets the outputs on the mainboard. Parameters connect (bool): connect LED. l6 (bool): pin 6. l5 (bool): pin 5. l4 (bool): pin 4. l3 (bool): pin 3. l2 (bool): pin 2. l1 (bool): pin 1. l0 (bool): pin 0. Returns - None horn Definiton - horn(on) -> None Description - Sets the outputs on the mainboard. Parameters - on (bool): 0 turns the buzzer off, 1 turns the buzzer on. Returns - None","title":"Imports"},{"location":"imports/#imports","text":"This section contains all imports made by Solderix and goes through every function each module has.","title":"Imports"},{"location":"imports/#oled","text":"The OLED is a monochromatic display with dimensions of 128\u00d764. To interface with it, a Solderix Adapter board is required. When calling import oled the display will automatically configure itself and turn on.","title":"OLED"},{"location":"imports/#poweroff","text":"Definiton - poweroff() -> None Description - Powers off the display. Parameters - None Returns - None","title":"poweroff"},{"location":"imports/#contrast","text":"Definiton - contrast(contrast) -> None Description - Changes the pixel contrast. Parameters - contrast (byte): amount of contrast. Returns - None","title":"contrast"},{"location":"imports/#invert","text":"Definiton - invert(invert) -> None Description - Inverts or reverts pixels on the display. Parameters - invert (byte): 0 is non inverted, 1 is inverted. Returns - None","title":"invert"},{"location":"imports/#show","text":"Definiton - show() -> None Description - When writing to the display, pixels are first stored in an internal buffer. This avoids flickering caused by writing directly to the display. The entire buffer is then sent as one image. This function pushes that image to the display. from microbit import * import oled oled.text(\"test\",0,0) # will not be displayed oled.line(0,0, 128,64) # will not be displayed oled.show() # after this text and line will be displayed Parameters - None Returns - None","title":"show"},{"location":"imports/#fill","text":"Definiton - fill(col) -> None Description - Fills the entire screen with a colour. Parameters - col (byte): 0 is no colour, 1 is colour on. Returns - None","title":"fill"},{"location":"imports/#pixel","text":"Definiton - pixel(x,y,col) -> None Description - Draws a pixel at the given coordinates. Parameters: x (int): width coordinate. y (int): height coordinate. col (int): 0 is colour off, 1 is colour on. Returns - None","title":"pixel"},{"location":"imports/#text","text":"Definiton - text(string,x,y,col) -> None Description - Draws a string to the display. Parameters: string (string): string to be drawn. x (int): width coordinate. y (int): height coordinate. col (int): 0 is colour off, 1 is colour on. Returns - None","title":"text"},{"location":"imports/#bitmap","text":"Definiton - bitmap(buf,x,y,w,h) -> None Description - Draws a bitmap to the display. The bitmap is blitted, so when creating a custom bitmap, make sure to adhere to the padding standards. Parameters: buf (list): buffer that contains the bitmap. x (int): width coordinate. y (int): height coordinate. w (int): width. h (int): height. Returns - None","title":"bitmap"},{"location":"imports/#line","text":"Definiton - line(x1, y1, x2, y2, c) -> None Description - Draws a line to the display. Parameters: x1 (int): width coordinate for line start. y1 (int): heigth coordinate for line start. x2 (int): width coordinate for line end. y2 (int): height coordinate for line end. c (int): 0 is colour off, 1 is colour on. Returns - None","title":"line"},{"location":"imports/#rect","text":"Definiton - rect(x,y,w,h,c,f) -> None Description - Draws a rectangle to the display. Parameters: x (int): width coordinate for rectangle start. y (int): height coordinate for rectangle start. w (int): rectangle width. h (int): rectangle height. c (int): 0 is colour off, 1 is colour on. f (bool): 0 will keep the rectangle empty, 1 will fill the rectangle Returns - None","title":"rect"},{"location":"imports/#circle","text":"Definiton - circle(x,y,r,c,f) -> None Description - Draws a circle to the display. Parameters: x (int): width coordinate for circle start. y (int): height coordinate for circle start. r (int): circle radius. c (int): 0 is colour off, 1 is colour on. f (bool): 0 will keep the circle empty, 1 will fill the circle. Returns - None","title":"circle"},{"location":"imports/#proximity","text":"Sensor used to measure light intensity in lux and approximate object distance at short range.","title":"Proximity"},{"location":"imports/#lux","text":"Definiton - lux() -> float Description - Function that returns ambient light measurment. Parameters: - None Returns - Ambient light in lux. Returns None if no measurement was made.","title":"lux"},{"location":"imports/#detect","text":"Definiton - detect() -> int Description - Function used for object detection. The lower the return value, the farther the object. Since measurements can be inaccurate due to color effects, the return value represents intensity rather than exact distance. Parameters: - None Returns - Detected distance intensity.","title":"detect"},{"location":"imports/#servo","text":"Used for controlling the motherboard servo as well as the servo add-on. When calling import servo the module will automatically configure itself and turn on.","title":"Servo"},{"location":"imports/#definitions","text":"The module has two definitions, each corresponding to a servo pin on the Solderix Motherboard. front (pin): Servo on the front of the motherboard. back (pin): Servo on the back of the motherboard. Example: from microbit import * import servo for deg in range(180): servo.turn(servo.front, deg, True)","title":"Definitions"},{"location":"imports/#turn","text":"Definiton - turn(servo, value, convert=True) -> None Description Turns the servo to a desired position between 0 and 180 degrees. The range of the value parameter depends on the convert flag: If convert is True , value should be between 0 and 180, which is internally converted to a range of 90 to 500. If convert is False , value should already be in the range 90 to 500. Parameters: servo (int): servo to be set. Range goes from 0 to 15. value (int): position of the servo. convert (bool): sets conversion of the value parameter. Returns - None","title":"turn"},{"location":"imports/#expander","text":"Used to expand the QWIIC ports on the SolderBit. When calling import expander the module will automatically configure itself and turn on.","title":"Expander"},{"location":"imports/#select","text":"Definiton - select(channel) -> None Description - Turns one QWIIC port into 4 seperate QWIIC buses. Parameters: - channel (int): channel from 0 to 3. Returns - None","title":"select"},{"location":"imports/#gpio","text":"Used for expanding the SolderBit inputs and outputs.","title":"GPIO"},{"location":"imports/#definitions_1","text":"The module has four definitions: two for pin configuration and two for output logic levels. INPUT (int): sets pin as input. OUTPUT (int): sets pin as output. LOW (int): sets output low. HIGH (int): sets output low high.","title":"Definitions"},{"location":"imports/#mode","text":"Definiton - mode(pin,mode) -> None Description - Configures a pin as input or output. To set it, use the INPUT and OUTPUT definitions. Parameters: pin (int): Pin number from 0 to 15. mode (int): IO mode (input/output). Returns - None","title":"mode"},{"location":"imports/#read","text":"Definiton - read(pin) -> int Description - If the pin is configured as an INPUT , it reads to logic level of the pin. Parameters: pin (int): Pin number from 0 to 15. Returns - 0 for logic level low, and 1 for logic level high.","title":"read"},{"location":"imports/#write","text":"Definiton - read(pin,state) -> None Description - If the pin is configured as an OUTPUT , writes a logic level to the pin. Parameters: pin (int): Pin number from 0 to 15. state (int): logic level. Use LOW and HIGH definitions. Returns - None","title":"write"},{"location":"imports/#ultrasonic","text":"Ultrasonic.","title":"Ultrasonic"},{"location":"imports/#distance","text":"Definiton - distance() -> int Description - Returns the distance to an object in centimetres. Parameters - None Returns - Returns the distance to an object in centimetres.","title":"distance"},{"location":"imports/#follower","text":"Infrared line follower.","title":"Follower"},{"location":"imports/#read_1","text":"Definiton - read(channel) -> int Description - Reads the intensity from the infrared sensor on the selected channel. Parameters - channel (int): channel to read ranging from 0 to 3. Returns - Returns the IR intensity.","title":"read"},{"location":"imports/#controller","text":"Module for the Joystick PRO.","title":"Controller"},{"location":"imports/#definitions_2","text":"Module has sixteen definitions, one for every input: JOY_X1 (int): left joystick input x. JOY_Y1 (int): left joystick input y. JOY_X2 (int): right joystick input x. JOY_Y2 (int): right joystick input y. JOY1_BTN (int): left joystick button. JOY2_BTN (int): right joystick button. R1_BTN (int): right side switch. L1_BTN (int): left side switch. LEFT_UP_BTN (int): left cluster upper button. LEFT_DOWN_BTN (int): left cluster lower button. LEFT_RIGHT_BTN (int): left cluster right button. LEFT_LEFT_BTN (int): left cluster left button. RIGHT_UP_BTN (int): right cluster upper button. RIGHT_DOWN_BTN (int): right cluster lower button. RIGHT_RIGHT_BTN (int): right cluster right button. RIGHT_LEFT_BTN (int): right cluster left button.","title":"Definitions"},{"location":"imports/#read_input","text":"Definiton - read_input(input, offset=True) -> int, bool Description - Reads the specified input from the joystick. Parameters - input (int): input to be read. - offset (bool): used for joystick center offestting. If set to true the rading will be offset to the center of the joystick. Returns - Returns an integer if reading a joystick, and a bool if reading a button.","title":"read_input"},{"location":"imports/#read_all_inputs","text":"Definiton - read_all_inputs() -> list Description - This function reads all inputs and returns them as a list. The list can be accessed using the input definitions provided by the module. Parameters - input (int): input to be read. - offset (bool): used for joystick center offestting. If set to true the rading will be offset to the center of the joystick. Returns - Returns an integer if reading a joystick, and a bool if reading a button.","title":"read_all_inputs"},{"location":"imports/#read_encoded","text":"Definiton - read_encoded() -> bytearray Description - Reads all inputs and encodes them in a bytearray. Parameters - None Returns - Encoded bytearray.","title":"read_encoded"},{"location":"imports/#data_decode","text":"Definiton - data_decode(data) -> list Description - Decodes an encoded bytearray. Parameters - data (bytearray): data to be decoded. Returns - Decoded data.","title":"data_decode"},{"location":"imports/#srt","text":"Module for the Joystick SRT.","title":"SRT"},{"location":"imports/#definitions_3","text":"Module has sixteen definitions, one for every input: JOY_X1 (int): left joystick input x. JOY_Y1 (int): left joystick input y. JOY_X2 (int): right joystick input x. JOY_Y2 (int): right joystick input y. JOY1_BTN (int): left joystick button. JOY2_BTN (int): right joystick button. R1_BTN (int): right side switch. L1_BTN (int): left side switch. LEFT_UP_BTN (int): left cluster upper button. LEFT_DOWN_BTN (int): left cluster lower button. LEFT_RIGHT_BTN (int): left cluster right button. LEFT_LEFT_BTN (int): left cluster left button. RIGHT_UP_BTN (int): right cluster upper button. RIGHT_DOWN_BTN (int): right cluster lower button. RIGHT_RIGHT_BTN (int): right cluster right button. RIGHT_LEFT_BTN (int): right cluster left button.","title":"Definitions"},{"location":"imports/#read_all_inputs_1","text":"Definiton - read_all_inputs() -> list Description - This function reads all inputs and returns them as a list. The list can be accessed using the input definitions provided by the module. Parameters input (int): input to be read. offset (bool): used for joystick center offestting. If set to true the rading will be offset to the center of the joystick. Returns - Returns an integer if reading a joystick, and a bool if reading a button.","title":"read_all_inputs"},{"location":"imports/#read_encoded_1","text":"Definiton - read_encoded() -> bytearray Description - Reads all inputs and encodes them in a bytearray. Parameters - None Returns - Encoded bytearray.","title":"read_encoded"},{"location":"imports/#data_decode_1","text":"Definiton - data_decode(data) -> list Description - Decodes an encoded bytearray. Parameters - data (bytearray): data to be decoded. Returns - Decoded data.","title":"data_decode"},{"location":"imports/#vehicle","text":"Module for vehicle controls.","title":"Vehicle"},{"location":"imports/#globals","text":"acceleration (float): Sets the acceleration rate of the vehicle from 0.0 to 1.0 in increments of 0.01. speed (float): Sets the speed rate of the vehicle from 0.0 to 1.0 in increments of 0.01.","title":"Globals"},{"location":"imports/#move","text":"Definiton - move(x,y,delay) -> None Description - Reads the encoded bytearray and. Parameters x (int): horizintal movement. y (int): vertical movement. delay (int): how long should the function block for. Returns - None","title":"move"},{"location":"imports/#set_outputs","text":"Definiton - set_outputs(connect, l6, l5, l4, l3, l2, l1, l0) -> None Description - Sets the outputs on the mainboard. Parameters connect (bool): connect LED. l6 (bool): pin 6. l5 (bool): pin 5. l4 (bool): pin 4. l3 (bool): pin 3. l2 (bool): pin 2. l1 (bool): pin 1. l0 (bool): pin 0. Returns - None","title":"set_outputs"},{"location":"imports/#horn","text":"Definiton - horn(on) -> None Description - Sets the outputs on the mainboard. Parameters - on (bool): 0 turns the buzzer off, 1 turns the buzzer on. Returns - None","title":"horn"}]}